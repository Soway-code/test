#include "BSP.h"
#include "sensor_dallas_ds18b20.h"
extern TIM_HandleTypeDef TIM3_Handler;
//#include <intrinsics.h>
//GPIO_InitTypeDef GPIO_InitStructure;


const unsigned char SRAM_DATA[SRAM_DATA_NUM] = {
0x00,0x00,0x00,0x62,0x63,0x00,0x65,0xBE,0x01,0x20,0x26,0x42,0x5C,0x48,0xA0,0x03,
0x21,0xE4,0x20,0x31,0xA1,0x03,0x21,0xE4,0x20,0x31,0x84,0x01,0x23,0x63,0x01,0x00,
0x00,0x00,0x00,0x00,0x20,0x0B,0x43,0x58,0xC0,0xFE,0x43,0xC0,0x44,0x7A,0x7E,0x20,
0x0B,0xC0,0xC0,0xC0,0xC8,0xFF,0x43,0xED,0x44,0xC0,0xC0,0xC0,0xF6,0xFF,0x43,0xEC,
0x44,0xC0,0xC0,0xC0,0xC8,0xFF,0x41,0x23,0x94,0xD0,0x43,0xEE,0x44,0xD2,0x43,0xEF,
0x44,0x20,0x5A,0x70,0x60,0x71,0x61,0x78,0x68,0x02,0x7A,0xF3,0x43,0xC7,0xFE,0x41,
0xEB,0x45,0x5A,0x21,0xDF,0x46,0x46,0x46,0x46,0xEC,0x44,0xC0,0xC0,0xC0,0xC8,0xFF,
0x43,0x55,0xED,0x45,0xEC,0x51,0xF4,0x41,0x23,0x88,0xEA,0x45,0xF5,0x41,0x23,0x88,
0xE9,0x45,0x1D,0x41,0x43,0x58,0xEA,0x21,0x99,0xE9,0x50,0x46,0xEB,0x44,0xA9,0x02,
0xEB,0x59,0x43,0xCA,0xFE,0x41,0x5C,0xA8,0x03,0xC0,0x5A,0xEB,0x45,0xEB,0x41,0xF2,
0x45,0xF6,0x41,0x23,0x88,0xEA,0x45,0xF7,0x41,0x23,0x88,0xE9,0x45,0x1F,0x41,0x43,
0x58,0xEA,0x21,0x99,0xE9,0x50,0x46,0xEB,0x44,0xA9,0x02,0xEB,0x59,0x43,0xCA,0xFE,
0x41,0x5C,0xA8,0x03,0xC0,0x5A,0xEB,0x45,0xEB,0x41,0xF3,0x45,0x02,0xFF,0xFF,0xFF,
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x7C,0x7D,0x45,0x41,0x02,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0xF0,0x7C,0x6D,0x45,0x41,0x6C,0x7D,0x45,0x41,0x02,0x47,0x47,
0x47,0x47,0x47,0x47,0x47,0xF0,0x6C,0x7D,0x45,0x41,0x02,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0xF0,0x7C,0x6D,0x45,0x41,0x45,0x41,0x02,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0xF0,0x7C,0x6D,0x45,0x41,0x02,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x02,0x4F,
0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,
0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,
0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x02,
0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,
0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,
0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,
0x02,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,
0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,
0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,
0x56,0x02,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,
0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,
0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,
0x5E,0x5E,0x5E,0x02,0x6A,0xFD,0x43,0x40,0x4F,0x4F,0x4F,0xEB,0x45,0x7A,0xF9,0x41,
0x43,0x58,0xEB,0x21,0x99,0xEA,0x44,0xC0,0xC0,0xC0,0xF1,0xFF,0x43,0xEC,0x44,0xC0,
0xC0,0xC0,0xC8,0xFF,0x41,0xED,0x45,0xC0,0x41,0xC0,0xC0,0xC0,0xF8,0xFF,0x43,0xE9,
0x44,0x6A,0x1D,0x43,0xAB,0x01,0xEA,0x58,0x8E,0x03,0xEC,0x53,0x1D,0x50,0x1F,0x44,
0xEC,0x53,0xED,0x53,0xE9,0x43,0xEC,0x58,0xAC,0xE6,0x8E,0x26,0xC0,0xC0,0xC0,0xF9,
0xFF,0x43,0xEC,0x44,0xC0,0xC0,0xC0,0xC8,0xFF,0x43,0xED,0x44,0xC0,0x41,0xC0,0xC0,
0xC0,0xFC,0xFF,0x43,0xE9,0x44,0x1D,0x43,0x1F,0x59,0xE9,0x43,0xED,0x53,0xEC,0x53,
0x58,0xAC,0xF2,0x7A,0xC0,0xC0,0xC0,0xC9,0xFF,0x43,0xEC,0x44,0xE7,0x44,0xE8,0x44,
0xC0,0xC0,0xC0,0xC8,0xFF,0x43,0xED,0x44,0x1F,0x43,0x4E,0x4E,0x4E,0x44,0xC0,0xC0,
0xC0,0xCF,0xFF,0x43,0xE9,0x44,0x8E,0x07,0xC0,0xC0,0xC0,0xCB,0xFF,0x43,0xE9,0x44,
0x40,0x5D,0x1D,0x43,0x1F,0x21,0xCA,0xE8,0x43,0xEC,0x44,0x1D,0x45,0xF8,0x43,0xAB,
0x0C,0xC0,0x41,0xED,0x53,0x53,0x1F,0x43,0x4E,0x4E,0x4E,0x44,0xE7,0x53,0xC0,0x41,
0xE8,0x53,0xE7,0x53,0x41,0xEC,0x45,0xE9,0x43,0x5C,0xAC,0xD3,0xC0,0xC0,0xC0,0xCF,
0xFF,0x43,0xE9,0x44,0xE8,0x41,0xE9,0x43,0x5C,0xA8,0x0C,0xC0,0x41,0xE8,0x43,0x53,
0xEC,0x44,0x1D,0x44,0x59,0x43,0xAB,0xEB,0xC8,0x43,0x46,0x46,0x46,0x44,0x7A,0x8A,
0x1B,0xC0,0x43,0x40,0x5D,0x5D,0x90,0x15,0xC8,0x45,0xC9,0x45,0xF8,0x43,0xAA,0x0B,
0xCA,0x45,0xCB,0x45,0xCC,0x45,0xCD,0x45,0xCE,0x45,0xCF,0x45,0x00,0x02,0xC0,0x43,
0x4E,0x4E,0xEA,0x44,0xE9,0x44,0x8E,0x06,0xC0,0x43,0x4E,0xEA,0x44,0xE9,0x44,0xF8,
0x43,0xAB,0x13,0xC0,0x43,0x4E,0xEA,0x44,0x4E,0x50,0xE9,0x44,0x8E,0x08,0xC0,0x43,
0xEA,0x44,0x4E,0x4E,0x50,0xE9,0x44,0xC0,0xC0,0xC0,0xC8,0xFF,0x43,0x4E,0x4E,0xE9,
0x51,0x91,0x01,0x23,0x5A,0xEA,0x43,0xE9,0x51,0x92,0x01,0x23,0x5A,0xEA,0x43,0xE9,
0x51,0x93,0x01,0x23,0x5A,0xEA,0x43,0xE9,0x51,0x94,0x01,0x23,0x5A,0xEA,0x43,0xE9,
0x51,0x95,0x01,0x23,0x5A,0xEA,0x43,0xE9,0x51,0x96,0x01,0x23,0x5A,0xEA,0x43,0xE9,
0x51,0x97,0x01,0x23,0x5A,0xEA,0x43,0xE9,0x51,0x02,0xE9,0x43,0x46,0x46,0xEC,0x44,
0x1D,0x45,0x02,0x7A,0xFA,0x41,0x4F,0x4F,0x4F,0xE7,0x45,0x5A,0xFB,0x43,0xE7,0x75,
0x21,0xCA,0x65,0xD0,0x45,0x5A,0xFC,0x43,0xE7,0x21,0xCA,0xD1,0x45,0x5A,0xFD,0x43,
0xE7,0x21,0xCA,0xD2,0x45,0x79,0x69,0x02,0xD7,0xFE,0x43,0xE7,0x45,0x5D,0xAD,0x01,
0x5D,0x45,0x41,0x02,0x1F,0x43,0x1D,0x44,0xC0,0x43,0xEC,0x51,0xED,0x51,0x5D,0xAA,
0xF2,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};


//配置寄存器
//单一接地模式
//参考电容接PC0，传感器接PC1，内部放电电阻30K
//参考电容660pF
//温度补偿方式：关闭
//RDC，PWM/PDM 不需要
//电容测量触发模式：软件触发
const unsigned long REG[REG_CONF_NUM]={
0xC04200FF,//addr0 0xC04200FF
             //0X4; 
             //0Bxx(MECOMP):; 
             //0B10; 
             //0Xxx(ECC_MODE):; 
             //0Xx(AUTOBOOT_DIS):; 
             //0Xx(MEM_LOCK_DIS):; 
0xC1201022,//addr1 0xC1201022 固定
0xC203160B,//0xC203160B,//addr2 0xC203160B
             //0Xxx(CMEAS_PORT_EN):CDC使能,开启PC7-PC0;           0X03,开启PC0，PC1
             //0Bxxxxx(CMEAS_BITS):传感器连接 00010-接地电容单一或差分 01000-漂移单一电容 10000-漂移差分电容; ?   0B00010 接地电容单一或差分
             //0Bxxx(RDCHG_INT_SEL):内部电阻选择 100-180K 101-90K 110-30K 111-10K; 111 电阻越小频率越小精度越低   0B101 90K
             //0X0B; 
0xC30D2200,//addr3 0xC3002001,0xC3002064
             //0Bxx(CY_CLK_SEL):CDC循环的时钟基准 0-20us 2-1us(当外部4M晶振时) 3-0.25us(当外部4M晶振时); 0B00
             //0B0;
             //0Bxxxxx(SEQ_TIME):在时钟-触发模式设置触发的周期(TMEAS_TRIG_SEL=2) 0-关闭;                 0B00000
             //0B0;
             //0Bxx(CMEAS_FAKE):设定CDC每次测量的后的假测量次数，可从0到4选择;                           0B01 2次
             //0Bxxx...(C_AVRG):CDC测量后内部平均的次数。设置为0无效，默认为1;                           0B0000000000001  100次 064
0xC4000210,//addr4 0xC4200500,,0xC4002F00
             //0B00;
             //0Bxx(CMEAS_STARTPIN):选择相应的输出电容测量的脉冲触发管脚 0-PG0 1-PG1 2-PG2 3-PG3;        0B10-PG2
             //0Bxx(CMEAS_TRIG_SEL):选择电容测量的触发源 0-仅软件触发 1-持续模式 2-时钟触发模式 3-脉冲触发模式;      0B00 -仅软件触发
             //0Bxxxxxxxxxx(CMEAS_CYTIME):设置用于电容测量的CDC周期时间 (CMEAS_CYTIME+1)*Clock_PeriodClock_period=20us/1us/0.25us根据CYCLKSEL=0/2/3;  0X05   //2次假测量，100次平均
             //0B000;
             //0Bx(TMEAS_CYTIME):设置用于温度测量的周期时间 0-140us(推荐) 1-280us;                           0-140us
             //0Bxx(TMEAS_STARTPIN):选择用于温度测量的脉冲触发管脚 0-PG0 1-PG1 2-PG2 3-PG3;                  0-PG0
             //0Bxx(TMEAS_TRIG_SEL):选择温度测量的触发源.选项2和3请不要应用; 0-关闭/操作码触发 1-CMEAS-触发(通过C-测量,推荐) 2-时钟触发模式 3-脉冲触发模式
0xC5800000,//addr5 0xC5000000
             //0Bxx(T_AVRG):0-1无平均 1-4次平均 2-8次平均 3-16次平均; 
             //0Bxxx...(TMEAS_TRIG_PREDIV):RDC相对于CDC的测量出现的次数 0为1次; 
0xC600C940,//addr6 0xC6004340
             //0X00; 
             //0Bx(TMEAS_FAKE):0-2次假测量 1-8次假测量;               0
             //0Bxxxxxxx(TMEAS_7BITS):选择温度补偿的连接方式;       
             //0X40; 固定
0xC71F0000,//addr7 0xC71F0000 固定
0xC8800310,//addr8 0xC8800010 DSP设置
			 //0Bx(DSP_SRAM_SEL):为单片机选择程序存储空间 0-OTP,1-SRAM                               0B1
			 //0Bx(DSP_START) :单片机的开始命令; 单片机的时钟开始工作,程序器跳转到地址0然后处理器开始运行.当固件完成后,DSP将会停止其自身的时钟.
			 //0Bx(DSPSTARTONOVL):0
			 //0Bx(DSP_STARTONTEMP)0
			 //0Bxxxx(DSP_STARTPIN):激活锁存触发的给出管脚,16 = PG0,17 = PG1,18 = PG2,19 = PG               0B0000
			 //0Bxxxx(DSP_FF_IN):激活锁存触发的给出管脚,12 = PG0,13 = PG1,14 = PG2,15 = PG3                 0B0000
			 //0Bxx(DSP_WATCHDOG_LENGTH):0
			 //0Bxx(DSP_MOFLO_EN):0
			 //0B00
			 //0Bxx(DSP_SPEED):设置 DSP 速度  1 = 标准 (快速),3 = 低功耗(慢速)                              0B01
			 //0B0
			 //0Bx(INT2PG2)在QFN24封装下有作用,因为这个时候没有INTN中断管脚.允许将中断信号通过PG2端口输出. 0
			 //0B00
0xC9BF208F,//addr9 0xC9DF2003 PWM/PDM设置
			 //0Bxxxx(PG_DIR_IN):将输出切换为输入(PG3/位23 到 PG0/位20).0-输出，1-输入                      0B1101，PG2输出
			 //0Bxxxx(PG_PULL_UP):在 PG0 到 PG3 线上开启上拉电阻;                                           0B1111
			 //0Bxxxx(PI_EN):开启脉冲密度或者脉冲宽度调制码输出。0Bxx10 = PDM0 开启                         0B0010  开启PDM0 
			 //0Bxxxx(PI1_CLK_SEL)对于脉冲接口的基础频率,基于内部低频振荡(OLF)或者外部高频晶振 (OHF)        0X0
			 //0Bxxxx(PI0_CLK_SEL)                                                                          0X0
			 //0Bxx(PI1_RES):脉冲输出的精度0 = 7 bit1 = 8, bit2 = 9, bit,3 = 10 bit,                        0
			 //0Bxx(PI0_RES):脉冲输出的精度                                                                 0X03 10 bit
0xCA180047,//addr10 0xCA180087
             //0X1800
             //0Xxx(V_CORE_CTL):控制1.8 V 核心电压调节器 0x47-标准 0x87-低功耗                              标准0x47
0xCB000000,//addr11
0xCC000000,//addr12
0xCD000000,//addr13
0xCE000000,//addr14
0xCF000000,//addr15
0xD0000000,//addr16
0xD1000000,//addr17
0xD2000000,//addr18
0xD3200000,//addr19
0xD4000001,//addr20
};

unsigned long PCap_Status = 0;
unsigned long ulWritePCAPXramErr = 0;
BitAction PCap_Ready = Bit_RESET;

#define SET_SCK             HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_SET);
#define CLR_SCK             HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, GPIO_PIN_RESET);

#define SET_MOSI            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
#define CLR_MOSI            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);

#define SET_SSN             HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_SET);
#define CLR_SSN             HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_RESET);

#define READ_MISO			HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_4)

//SSN脚拉低,开始发送数据
void SPI_Enable(void)
{
   // GPIO_ResetBits(GPIOA, GPIO_Pin_15);
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_RESET);

    for(unsigned long i = 0; i < 7; i++)    
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    __NOP();
		__NOP();
}

//SSN脚置高,结束发送数据

void SPI_Disable(void)
{	
//  GPIO_SetBits(GPIOA, GPIO_Pin_15);
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_SET);
    __NOP();
    __NOP();
    __NOP();
}


//spi send 0
void spi_send_0(void)
{
	SET_SCK;
	CLR_MOSI;
	CLR_SCK;
    for(unsigned long i = 0; i < 4; i++)    
        __NOP();
        __NOP();
}

//spi send 1
void spi_send_1(void)
{
	SET_SCK;
	SET_MOSI;
	CLR_SCK;
    for(unsigned long i = 0; i < 4; i++)    
        __NOP();
	    __NOP();
}

void spi_write8(unsigned char wbuf8)
{
	unsigned long i;

	for(i = 0; i < 8;i++)
	{
		if(wbuf8 & 0x80) //若最高位为1
			spi_send_1();
		else 
			spi_send_0();

		wbuf8 = wbuf8 << 1; //左移一位，第二高位变成最高位，开始下一次写了数据
	}
}

void spi_write16(unsigned int wbuf16)
{
	unsigned long i;

	for(i = 0; i < 16;i++)
	{
		if(wbuf16 & 0x8000) //若最高位为1
			spi_send_1();
		else 
			spi_send_0();

		wbuf16 = wbuf16 << 1;//左移一位，第二高位变成最高位，开始下一次写了数据
	}
}

void spi_write32(unsigned long wbuf32)
{
	unsigned long i;
	
	for(i = 0; i < 32;i++)
	{
		if(wbuf32 & 0x80000000) //若最高位为1
			spi_send_1();
		else 
			spi_send_0();

		wbuf32 = wbuf32 << 1;//左移一位，第二高位变成最高位，开始下一次写了数据
	}
}

//SPI 读8位
unsigned char spi_read8()
{
	unsigned long cnt;
	unsigned char rcvdata = 0x00;

	for(cnt = 8; cnt > 0;cnt--)
	{
		rcvdata <<= 1; 
		SET_SCK;
        __NOP();
        __NOP();
		if(READ_MISO)           //
			rcvdata |=1;
		CLR_SCK;
		for(unsigned long i = 0; i < 9; i++)    
            __NOP();
	          __NOP();
 	}
	return rcvdata;
}

//SPI 读24位
unsigned long spi_read24()
{
	unsigned long cnt;
	unsigned long rcvdata = 0x00000000;

	for(cnt = 24;cnt > 0;cnt--)
	{
		rcvdata <<= 1; 
		SET_SCK;
        __NOP();
        __NOP();
		if(READ_MISO)
			rcvdata |=1;
		CLR_SCK;
		for(unsigned long i = 0; i < 9; i++)    
            __NOP();
	          __NOP();
	}
	return rcvdata;
}

//上电复位指令
void PCap_Reset(void)
{
    SPI_Enable();
	spi_write8(0x88);
	SPI_Disable();
}

//部分复位指令
void PCap_PTL_Reset(void)
{
    SPI_Enable();
	spi_write8(0x8A);
	SPI_Disable();
}

//电容测量指令
void PCap_MEASURE(void)
{
    SPI_Enable();
	spi_write8(0x8C);
	SPI_Disable();
}

//启动PCap
void PCap_Enable(void)
{
    SPI_Enable();
	spi_write32(0xD4000001);  //addr20
	SPI_Disable();
}

unsigned long PCap_WR_SRAM(void)       //把固件写入SRAM中，128个字节
{
    unsigned short i = 0;
  	unsigned char test_write = 0x00;
	unsigned char test_read  = 0x00;
	unsigned long ErrCnt = 0;

    for(i = 0; i < SRAM_DATA_NUM; i++)
	{
	    test_write = SRAM_DATA[i];
	    
		//SRAM 写
		SPI_Enable();
	    spi_write16(i | 0x9000);
		spi_write8(test_write);
		SPI_Disable();
//		Delay_Us(50);
		rt_hw_us_delay(50);

		//SARM 读		
		SPI_Enable();
		spi_write16(i | 0x1000);         //读地址为0位置的数据
		test_read = spi_read8();
		SPI_Disable();

        if(test_read != test_write)
        {
            rt_kprintf("PCap_WR_SRAM通信测试失败\n");
            ErrCnt++;
    		if(ErrCnt > 10) return 1;    //通信测试失败     (只读200次)
//    		Delay_Us(50);
				rt_hw_us_delay(50);
    		i -= 1;
        }
	}
	
	return 0;                    //通信测试成功
}


//PCap 寄存器配置
void PCap_Reg_Config(void)
{
	unsigned long i ;
	for(i = 0;i < REG_CONF_NUM;i++)      //写20个配置突破口
	{
	    SPI_Enable();
		spi_write32(REG[i]);
		SPI_Disable();
	}
}

uint32_t PCap_Res_Temp(void)
{
	unsigned long cap_res_temp = 0;

	//读结果寄存器1 
	SPI_Enable();
	spi_write8(0x4D);
	//delayMs(5);
	cap_res_temp = spi_read24();
	SPI_Disable();

	return cap_res_temp;
}

unsigned long PCap_Res_Value(void)
{
	unsigned long cap_res = 0;

	//读结果寄存器1 
	SPI_Enable();
	spi_write8(0x41);
	cap_res = spi_read24();
	SPI_Disable();
	
	return	cap_res; 
}



unsigned long PCap1_Res_Value(void)
{
	unsigned long cap_res = 0;

	//读结果寄存器1 
	SPI_Enable();
	spi_write8(0x42);
	cap_res = spi_read24();
	SPI_Disable();
	
	return	cap_res; 
}

unsigned long PCap_Res_Stau(void)
{
	//unsigned long cap_stau = 0;

	//读结果寄存器1 
	SPI_Enable();
	spi_write8(0x48);
	PCap_Status = spi_read24();
	SPI_Disable();
	return	PCap_Status; 
}

void PCap_SPI_Init(void)
{
		GPIO_InitTypeDef GPIO_InitStruct;
    /* Enable SCK, MOSI, MISO and NSS GPIO clocks */
  //  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB, ENABLE);    
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();
    /* SPI SCK pin configuration */
	GPIO_InitStruct.Pin = GPIO_PIN_3;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* SPI  MOSI pin configuration */
	GPIO_InitStruct.Pin = GPIO_PIN_5;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* SPI MISO pin configuration */
	GPIO_InitStruct.Pin = GPIO_PIN_4;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* software Chip Select pin Configuration*/
	GPIO_InitStruct.Pin = GPIO_PIN_15;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

}

void PCap_Init(void)
{
    unsigned short wrSRAMCnt = 0;
    
    PCap_SPI_Init();
//    Delay_Ms(1);
    rt_thread_mdelay(1);
  	PCap_Reset();				//上电复位
	rt_thread_mdelay(1);
    
    do{
        //before this, wdog is no initiate, so don't feed the wdog in here
        ulWritePCAPXramErr = PCap_WR_SRAM();
        if(0 == ulWritePCAPXramErr)
            break;
        wrSRAMCnt++;
		rt_thread_mdelay(10);
    }
    while(wrSRAMCnt < 10);
//    Delay_Us(10);
    rt_hw_us_delay(10);
    PCap_Reg_Config();			//配置寄存器
    rt_hw_us_delay(10);

    PCap_Enable();				//启动PCap芯片
    rt_hw_us_delay(1);

    PCap_PTL_Reset();			//部分上电复位（SRAM和配置寄存器值不变）
    rt_hw_us_delay(1);

    PCap_MEASURE(); 					//测量当前点
    rt_hw_us_delay(1);

	//Capture_TimerInit();
}

void resetPcap(void)
{
    static unsigned char ucResetCnt = 0;
    unsigned short wrSRAMCnt = 0;

    if(++ucResetCnt >= 3)
    {
        ucResetCnt = 0;
        //reboot
        NVIC_SystemReset(); //define in ..\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\core_cm0.h
        while(1)
        {;}
    }
    else
    {
        //disable timer interrupt
//        TIM_ITConfig(TIM3, TIM_IT_Update, DISABLE);
//        TIM_Cmd(TIM3, DISABLE);
//        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    	 __HAL_TIM_CLEAR_IT(&TIM3_Handler, TIM_IT_UPDATE);
        //Disable pcap, if SPI is work normally, the action will quickly reset pcap,and shut down the convert
        PCap_Reset();
        
        //initiate pcap
    
        PCap_SPI_Init();
        rt_thread_mdelay(1);
        
    	PCap_Reset();				//上电复位
    	rt_thread_mdelay(1);
        
        do{
//#if IWDG_EN > 0
//            IWDG_ReloadCounter();
//#endif
            if(0 == PCap_WR_SRAM())
                break;
            wrSRAMCnt++;
            rt_hw_us_delay(10);
        }
        while(wrSRAMCnt < 10);
        rt_hw_us_delay(10);
        
    	PCap_Reg_Config();			                                //配置寄存器
    	rt_hw_us_delay(10);

//#if IWDG_EN > 0
//        IWDG_ReloadCounter();
//#endif

    	PCap_Enable();				                                //启动PCap芯片
    	rt_thread_mdelay(1);

    	PCap_PTL_Reset();			                                //部分上电复位（SRAM和配置寄存器值不变）
        rt_thread_mdelay(1);

    	PCap_MEASURE(); 					                //测量当前点
    }
}
